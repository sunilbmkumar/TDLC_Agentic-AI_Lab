"use strict";exports.id=172,exports.ids=[172],exports.modules={172:(nt,te,d)=>{d.d(te,{ENV_CMDS_FULL_URI:()=>C,ENV_CMDS_RELATIVE_URI:()=>T,fromContainerMetadata:()=>fe,fromInstanceMetadata:()=>ze,getInstanceMetadataEndpoint:()=>z,httpRequest:()=>_});class p extends Error{constructor(t,n=!0){let o,s=!0;typeof n=="boolean"?(o=void 0,s=n):n!=null&&typeof n=="object"&&(o=n.logger,s=n.tryNextLink??!0),super(t),this.name="ProviderError",this.tryNextLink=s,Object.setPrototypeOf(this,p.prototype),o?.debug?.(`@smithy/property-provider ${s?"->":"(!)"} ${t}`)}static from(t,n=!0){return Object.assign(new this(t.message,n),t)}}class f extends p{constructor(t,n=!0){super(t,n),this.name="CredentialsProviderError",Object.setPrototypeOf(this,f.prototype)}}class M extends p{constructor(t,n=!0){super(t,n),this.name="TokenProviderError",Object.setPrototypeOf(this,M.prototype)}}const ne=(...e)=>async()=>{if(e.length===0)throw new p("No providers in chain");let t;for(const n of e)try{return await n()}catch(o){if(t=o,o?.tryNextLink)continue;throw o}throw t},oe=e=>()=>Promise.resolve(e),se=(e,t,n)=>{let o,s,r,i=!1;const a=async()=>{s||(s=e());try{o=await s,r=!0,i=!1}finally{s=void 0}return o};return t===void 0?async c=>((!r||c?.forceRefresh)&&(o=await a()),o):async c=>((!r||c?.forceRefresh)&&(o=await a()),i?o:n&&!n(o)?(i=!0,o):(t(o)&&await a(),o))};var re=d(87016),ae=d(20181),ie=d(58611);function _(e){return new Promise((t,n)=>{const o=(0,ie.request)({method:"GET",...e,hostname:e.hostname?.replace(/^\[(.+)\]$/,"$1")});o.on("error",s=>{n(Object.assign(new p("Unable to connect to instance metadata service"),s)),o.destroy()}),o.on("timeout",()=>{n(new p("TimeoutError from instance metadata service")),o.destroy()}),o.on("response",s=>{const{statusCode:r=400}=s;(r<200||300<=r)&&(n(Object.assign(new p("Error response received from instance metadata service"),{statusCode:r})),o.destroy());const i=[];s.on("data",a=>{i.push(a)}),s.on("end",()=>{t(ae.Buffer.concat(i)),o.destroy()})}),o.end()})}const b=e=>Boolean(e)&&typeof e=="object"&&typeof e.AccessKeyId=="string"&&typeof e.SecretAccessKey=="string"&&typeof e.Token=="string"&&typeof e.Expiration=="string",L=e=>({accessKeyId:e.AccessKeyId,secretAccessKey:e.SecretAccessKey,sessionToken:e.Token,expiration:new Date(e.Expiration),...e.AccountId&&{accountId:e.AccountId}}),ce=1e3,le=0,k=({maxRetries:e=le,timeout:t=ce})=>({maxRetries:e,timeout:t}),N=(e,t)=>{let n=e();for(let o=0;o<t;o++)n=n.catch(e);return n},C="AWS_CONTAINER_CREDENTIALS_FULL_URI",T="AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",V="AWS_CONTAINER_AUTHORIZATION_TOKEN",fe=(e={})=>{const{timeout:t,maxRetries:n}=k(e);return()=>N(async()=>{const o=await Ee({logger:e.logger}),s=JSON.parse(await de(t,o));if(!b(s))throw new f("Invalid response received from instance metadata service.",{logger:e.logger});return L(s)},n)},de=async(e,t)=>(process.env[V]&&(t.headers={...t.headers,Authorization:process.env[V]}),(await _({...t,timeout:e})).toString()),ue="169.254.170.2",he={localhost:!0,"127.0.0.1":!0},pe={"http:":!0,"https:":!0},Ee=async({logger:e})=>{if(process.env[T])return{hostname:ue,path:process.env[T]};if(process.env[C]){const t=(0,re.parse)(process.env[C]);if(!t.hostname||!(t.hostname in he))throw new f(`${t.hostname} is not a valid container metadata service hostname`,{tryNextLink:!1,logger:e});if(!t.protocol||!(t.protocol in pe))throw new f(`${t.protocol} is not a valid container metadata service protocol`,{tryNextLink:!1,logger:e});return{...t,port:t.port?parseInt(t.port,10):void 0}}throw new f(`The container metadata credential provider cannot be used unless the ${T} or ${C} environment variable is set`,{tryNextLink:!1,logger:e})};function H(e){try{const t=new Set(Array.from(e.match(/([A-Z_]){3,}/g)??[]));return t.delete("CONFIG"),t.delete("CONFIG_PREFIX_SEPARATOR"),t.delete("ENV"),[...t].join(", ")}catch{return e}}const ge=(e,t)=>async()=>{try{const n=e(process.env);if(n===void 0)throw new Error;return n}catch(n){throw new f(n.message||`Not found in ENV: ${H(e.toString())}`,{logger:t})}};var me=d(70857),I=d(16928);const w={},Se=()=>process&&process.geteuid?`${process.geteuid()}`:"DEFAULT",y=()=>{const{HOME:e,USERPROFILE:t,HOMEPATH:n,HOMEDRIVE:o=`C:${I.sep}`}=process.env;if(e)return e;if(t)return t;if(n)return`${o}${n}`;const s=Se();return w[s]||(w[s]=(0,me.homedir)()),w[s]},_e="AWS_PROFILE",Ie="default",Ae=e=>e.profile||process.env[_e]||Ie;var ot=d(76982);const st=e=>{const n=createHash("sha1").update(e).digest("hex");return join(getHomeDir(),".aws","sso","cache",`${n}.json`)};var U=d(79896);const{readFile:Ce}=U.promises,rt=async e=>{const t=getSSOTokenFilepath(e),n=await Ce(t,"utf8");return JSON.parse(n)};var $;(function(e){e.HEADER="header",e.QUERY="query"})($||($={}));var j;(function(e){e.HEADER="header",e.QUERY="query"})(j||(j={}));var W;(function(e){e.HTTP="http",e.HTTPS="https"})(W||(W={}));var v;(function(e){e.MD5="md5",e.CRC32="crc32",e.CRC32C="crc32c",e.SHA1="sha1",e.SHA256="sha256"})(v||(v={}));const at=e=>{const t=[];return e.sha256!==void 0&&t.push({algorithmId:()=>v.SHA256,checksumConstructor:()=>e.sha256}),e.md5!=null&&t.push({algorithmId:()=>v.MD5,checksumConstructor:()=>e.md5}),{_checksumAlgorithms:t,addChecksumAlgorithm(n){this._checksumAlgorithms.push(n)},checksumAlgorithms(){return this._checksumAlgorithms}}},it=e=>{const t={};return e.checksumAlgorithms().forEach(n=>{t[n.algorithmId()]=n.checksumConstructor()}),t},ct=e=>({...getChecksumConfiguration(e)}),lt=e=>({...resolveChecksumRuntimeConfig(e)});var K;(function(e){e[e.HEADER=0]="HEADER",e[e.TRAILER=1]="TRAILER"})(K||(K={}));var A;(function(e){e.PROFILE="profile",e.SSO_SESSION="sso-session",e.SERVICES="services"})(A||(A={}));var G;(function(e){e.HTTP_0_9="http/0.9",e.HTTP_1_0="http/1.0",e.TDS_8_0="tds/8.0"})(G||(G={}));const Te=e=>Object.entries(e).filter(([t])=>{const n=t.indexOf(O);return n===-1?!1:Object.values(A).includes(t.substring(0,n))}).reduce((t,[n,o])=>{const s=n.indexOf(O),r=n.substring(0,s)===A.PROFILE?n.substring(s+1):n;return t[r]=o,t},{...e.default&&{default:e.default}}),ve="AWS_CONFIG_FILE",Oe=()=>process.env[ve]||(0,I.join)(y(),".aws","config"),Fe="AWS_SHARED_CREDENTIALS_FILE",Ne=()=>process.env[Fe]||(0,I.join)(y(),".aws","credentials"),we=/^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/,ye=["__proto__","profile __proto__"],B=e=>{const t={};let n,o;for(const s of e.split(/\r?\n/)){const r=s.split(/(^|\s)[;#]/)[0].trim();if(r[0]==="["&&r[r.length-1]==="]"){n=void 0,o=void 0;const a=r.substring(1,r.length-1),c=we.exec(a);if(c){const[,l,,E]=c;Object.values(A).includes(l)&&(n=[l,E].join(O))}else n=a;if(ye.includes(a))throw new Error(`Found invalid profile name "${a}"`)}else if(n){const a=r.indexOf("=");if(![0,-1].includes(a)){const[c,l]=[r.substring(0,a).trim(),r.substring(a+1).trim()];if(l==="")o=c;else{o&&s.trimStart()===s&&(o=void 0),t[n]=t[n]||{};const E=o?[o,c].join(O):c;t[n][E]=l}}}}return t},{readFile:De}=U.promises,D={},X=(e,t)=>((!D[e]||t?.ignoreCache)&&(D[e]=De(e,"utf8")),D[e]),J=()=>({}),O=".",Re=async(e={})=>{const{filepath:t=Ne(),configFilepath:n=Oe()}=e,o=y(),s="~/";let r=t;t.startsWith(s)&&(r=(0,I.join)(o,t.slice(2)));let i=n;n.startsWith(s)&&(i=(0,I.join)(o,n.slice(2)));const a=await Promise.all([X(i,{ignoreCache:e.ignoreCache}).then(B).then(Te).catch(J),X(r,{ignoreCache:e.ignoreCache}).then(B).catch(J)]);return{configFile:a[0],credentialsFile:a[1]}},ft=e=>Object.entries(e).filter(([t])=>t.startsWith(IniSectionType.SSO_SESSION+CONFIG_PREFIX_SEPARATOR)).reduce((t,[n,o])=>({...t,[n.substring(n.indexOf(CONFIG_PREFIX_SEPARATOR)+1)]:o}),{}),Pe=()=>({}),dt=async(e={})=>slurpFile(e.configFilepath??getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(Pe),ut=async e=>{const t=await loadSharedConfigFiles(e);return mergeConfigFiles(t.configFile,t.credentialsFile)},xe=(e,{preferredFile:t="config",...n}={})=>async()=>{const o=Ae(n),{configFile:s,credentialsFile:r}=await Re(n),i=r[o]||{},a=s[o]||{},c=t==="config"?{...i,...a}:{...a,...i};try{const E=e(c,t==="config"?s:r);if(E===void 0)throw new Error;return E}catch(l){throw new f(l.message||`Not found in config files w/ profile [${o}]: ${H(e.toString())}`,{logger:n.logger})}},Me=e=>typeof e=="function",be=e=>Me(e)?async()=>await e():oe(e),R=({environmentVariableSelector:e,configFileSelector:t,default:n},o={})=>se(ne(ge(e),xe(t,o),be(n)));class P extends f{constructor(t,n=!0){super(t,n),this.tryNextLink=n,this.name="InstanceMetadataV1FallbackError",Object.setPrototypeOf(this,P.prototype)}}var Le=d(57413);const Y=e=>{if(typeof e=="string")return Y(new URL(e));const{hostname:t,pathname:n,port:o,protocol:s,search:r}=e;let i;return r&&(i=(0,Le.J)(r)),{hostname:t,port:o?parseInt(o):void 0,protocol:s,path:n,query:i}};var F;(function(e){e.IPv4="http://169.254.169.254",e.IPv6="http://[fd00:ec2::254]"})(F||(F={}));const ke="AWS_EC2_METADATA_SERVICE_ENDPOINT",Ve="ec2_metadata_service_endpoint",He={environmentVariableSelector:e=>e[ke],configFileSelector:e=>e[Ve],default:void 0};var m;(function(e){e.IPv4="IPv4",e.IPv6="IPv6"})(m||(m={}));const Ue="AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",$e="ec2_metadata_service_endpoint_mode",je={environmentVariableSelector:e=>e[Ue],configFileSelector:e=>e[$e],default:m.IPv4},z=async()=>Y(await We()||await Ke()),We=async()=>R(He)(),Ke=async()=>{const e=await R(je)();switch(e){case m.IPv4:return F.IPv4;case m.IPv6:return F.IPv6;default:throw new Error(`Unsupported endpoint mode: ${e}. Select from ${Object.values(m)}`)}},Ge=5*60,Be=5*60,Xe="https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html",Q=(e,t)=>{const n=Ge+Math.floor(Math.random()*Be),o=new Date(Date.now()+n*1e3);t.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: `+Xe);const s=e.originalExpiration??e.expiration;return{...e,...s?{originalExpiration:s}:{},expiration:o}},Je=(e,t={})=>{const n=t?.logger||console;let o;return async()=>{let s;try{s=await e(),s.expiration&&s.expiration.getTime()<Date.now()&&(s=Q(s,n))}catch(r){if(o)n.warn("Credential renew failed: ",r),s=Q(o,n);else throw r}return o=s,s}},Z="/latest/meta-data/iam/security-credentials/",Ye="/latest/api/token",x="AWS_EC2_METADATA_V1_DISABLED",q="ec2_metadata_v1_disabled",ee="x-aws-ec2-metadata-token",ze=(e={})=>Je(Qe(e),{logger:e.logger}),Qe=(e={})=>{let t=!1;const{logger:n,profile:o}=e,{timeout:s,maxRetries:r}=k(e),i=async(a,c)=>{if(t||c.headers?.[ee]==null){let u=!1,h=!1;const tt=await R({environmentVariableSelector:g=>{const S=g[x];if(h=!!S&&S!=="false",S===void 0)throw new f(`${x} not set in env, checking config file next.`,{logger:e.logger});return h},configFileSelector:g=>{const S=g[q];return u=!!S&&S!=="false",u},default:!1},{profile:o})();if(e.ec2MetadataV1Disabled||tt){const g=[];throw e.ec2MetadataV1Disabled&&g.push("credential provider initialization (runtime option ec2MetadataV1Disabled)"),u&&g.push(`config file profile (${q})`),h&&g.push(`process environment variable (${x})`),new P(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${g.join(", ")}].`)}}const E=(await N(async()=>{let u;try{u=await qe(c)}catch(h){throw h.statusCode===401&&(t=!1),h}return u},a)).trim();return N(async()=>{let u;try{u=await et(E,c,e)}catch(h){throw h.statusCode===401&&(t=!1),h}return u},a)};return async()=>{const a=await z();if(t)return n?.debug("AWS SDK Instance Metadata","using v1 fallback (no token fetch)"),i(r,{...a,timeout:s});{let c;try{c=(await Ze({...a,timeout:s})).toString()}catch(l){if(l?.statusCode===400)throw Object.assign(l,{message:"EC2 Metadata token request returned error"});return(l.message==="TimeoutError"||[403,404,405].includes(l.statusCode))&&(t=!0),n?.debug("AWS SDK Instance Metadata","using v1 fallback (initial)"),i(r,{...a,timeout:s})}return i(r,{...a,headers:{[ee]:c},timeout:s})}}},Ze=async e=>_({...e,path:Ye,method:"PUT",headers:{"x-aws-ec2-metadata-token-ttl-seconds":"21600"}}),qe=async e=>(await _({...e,path:Z})).toString(),et=async(e,t,n)=>{const o=JSON.parse((await _({...t,path:Z+e})).toString());if(!b(o))throw new f("Invalid response received from instance metadata service.",{logger:n.logger});return L(o)}}};
