"use strict";exports.id=117,exports.ids=[117],exports.modules={27117:(Fe,ne,l)=>{l.d(ne,{fromSSO:()=>De});class I extends Error{constructor(s,t=!0){let o,n=!0;typeof t=="boolean"?(o=void 0,n=t):t!=null&&typeof t=="object"&&(o=t.logger,n=t.tryNextLink??!0),super(s),this.name="ProviderError",this.tryNextLink=n,Object.setPrototypeOf(this,I.prototype),o?.debug?.(`@smithy/property-provider ${n?"->":"(!)"} ${s}`)}static from(s,t=!0){return Object.assign(new this(s.message,t),s)}}class d extends I{constructor(s,t=!0){super(s,t),this.name="CredentialsProviderError",Object.setPrototypeOf(this,d.prototype)}}class p extends I{constructor(s,t=!0){super(s,t),this.name="TokenProviderError",Object.setPrototypeOf(this,p.prototype)}}const Ne=(...e)=>async()=>{if(e.length===0)throw new ProviderError("No providers in chain");let s;for(const t of e)try{return await t()}catch(o){if(s=o,o?.tryNextLink)continue;throw o}throw s};var re=l(70857),O=l(16928);const F={},ie=()=>process&&process.geteuid?`${process.geteuid()}`:"DEFAULT",A=()=>{const{HOME:e,USERPROFILE:s,HOMEPATH:t,HOMEDRIVE:o=`C:${O.sep}`}=process.env;if(e)return e;if(s)return s;if(t)return`${o}${t}`;const n=ie();return F[n]||(F[n]=(0,re.homedir)()),F[n]},ce="AWS_PROFILE",ae="default",j=e=>e.profile||process.env[ce]||ae;var le=l(76982);const b=e=>{const t=(0,le.createHash)("sha1").update(e).digest("hex");return(0,O.join)(A(),".aws","sso","cache",`${t}.json`)};var N=l(79896);const{readFile:fe}=N.promises,U=async e=>{const s=b(e),t=await fe(s,"utf8");return JSON.parse(t)};var K;(function(e){e.HEADER="header",e.QUERY="query"})(K||(K={}));var M;(function(e){e.HEADER="header",e.QUERY="query"})(M||(M={}));var W;(function(e){e.HTTP="http",e.HTTPS="https"})(W||(W={}));var D;(function(e){e.MD5="md5",e.CRC32="crc32",e.CRC32C="crc32c",e.SHA1="sha1",e.SHA256="sha256"})(D||(D={}));const Le=e=>{const s=[];return e.sha256!==void 0&&s.push({algorithmId:()=>D.SHA256,checksumConstructor:()=>e.sha256}),e.md5!=null&&s.push({algorithmId:()=>D.MD5,checksumConstructor:()=>e.md5}),{_checksumAlgorithms:s,addChecksumAlgorithm(t){this._checksumAlgorithms.push(t)},checksumAlgorithms(){return this._checksumAlgorithms}}},Pe=e=>{const s={};return e.checksumAlgorithms().forEach(t=>{s[t.algorithmId()]=t.checksumConstructor()}),s},_e=e=>({...getChecksumConfiguration(e)}),$e=e=>({...resolveChecksumRuntimeConfig(e)});var G;(function(e){e[e.HEADER=0]="HEADER",e[e.TRAILER=1]="TRAILER"})(G||(G={}));var E;(function(e){e.PROFILE="profile",e.SSO_SESSION="sso-session",e.SERVICES="services"})(E||(E={}));var V;(function(e){e.HTTP_0_9="http/0.9",e.HTTP_1_0="http/1.0",e.TDS_8_0="tds/8.0"})(V||(V={}));const ue=e=>Object.entries(e).filter(([s])=>{const t=s.indexOf(T);return t===-1?!1:Object.values(E).includes(s.substring(0,t))}).reduce((s,[t,o])=>{const n=t.indexOf(T),r=t.substring(0,n)===E.PROFILE?t.substring(n+1):t;return s[r]=o,s},{...e.default&&{default:e.default}}),he="AWS_CONFIG_FILE",Y=()=>process.env[he]||(0,O.join)(A(),".aws","config"),de="AWS_SHARED_CREDENTIALS_FILE",ge=()=>process.env[de]||(0,O.join)(A(),".aws","credentials"),Se=/^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/,pe=["__proto__","profile __proto__"],L=e=>{const s={};let t,o;for(const n of e.split(/\r?\n/)){const r=n.split(/(^|\s)[;#]/)[0].trim();if(r[0]==="["&&r[r.length-1]==="]"){t=void 0,o=void 0;const a=r.substring(1,r.length-1),i=Se.exec(a);if(i){const[,g,,c]=i;Object.values(E).includes(g)&&(t=[g,c].join(T))}else t=a;if(pe.includes(a))throw new Error(`Found invalid profile name "${a}"`)}else if(t){const a=r.indexOf("=");if(![0,-1].includes(a)){const[i,g]=[r.substring(0,a).trim(),r.substring(a+1).trim()];if(g==="")o=i;else{o&&n.trimStart()===n&&(o=void 0),s[t]=s[t]||{};const c=o?[o,i].join(T):i;s[t][c]=g}}}}return s},{readFile:me}=N.promises,P={},_=(e,s)=>((!P[e]||s?.ignoreCache)&&(P[e]=me(e,"utf8")),P[e]),J=()=>({}),T=".",we=async(e={})=>{const{filepath:s=ge(),configFilepath:t=Y()}=e,o=A(),n="~/";let r=s;s.startsWith(n)&&(r=(0,O.join)(o,s.slice(2)));let f=t;t.startsWith(n)&&(f=(0,O.join)(o,t.slice(2)));const a=await Promise.all([_(f,{ignoreCache:e.ignoreCache}).then(L).then(ue).catch(J),_(r,{ignoreCache:e.ignoreCache}).then(L).catch(J)]);return{configFile:a[0],credentialsFile:a[1]}},Ce=e=>Object.entries(e).filter(([s])=>s.startsWith(E.SSO_SESSION+T)).reduce((s,[t,o])=>({...s,[t.substring(t.indexOf(T)+1)]:o}),{}),Oe=()=>({}),Q=async(e={})=>_(e.configFilepath??Y()).then(L).then(Ce).catch(Oe),Ee=(...e)=>{const s={};for(const t of e)for(const[o,n]of Object.entries(t))s[o]!==void 0?Object.assign(s[o],n):s[o]=n;return s},X=async e=>{const s=await we(e);return Ee(s.configFile,s.credentialsFile)},Te=e=>e&&(typeof e.sso_start_url=="string"||typeof e.sso_account_id=="string"||typeof e.sso_session=="string"||typeof e.sso_region=="string"||typeof e.sso_role_name=="string");function z(e,s,t){return e.$source||(e.$source={}),e.$source[s]=t,e}const ye=5*60*1e3,$="To refresh this SSO session run 'aws sso login' with the corresponding profile.",xe=async(e,s={})=>{const{SSOOIDCClient:t}=await Promise.all([l.e(824),l.e(352)]).then(l.bind(l,4352));return new t(Object.assign({},s.clientConfig??{},{region:e??s.clientConfig?.region,logger:s.clientConfig?.logger??s.parentClientConfig?.logger}))},ke=async(e,s,t={})=>{const{CreateTokenCommand:o}=await Promise.all([l.e(824),l.e(352)]).then(l.bind(l,4352));return(await xe(s,t)).send(new o({clientId:e.clientId,clientSecret:e.clientSecret,refreshToken:e.refreshToken,grantType:"refresh_token"}))},B=e=>{if(e.expiration&&e.expiration.getTime()<Date.now())throw new p(`Token is expired. ${$}`,!1)},w=(e,s,t=!1)=>{if(typeof s>"u")throw new p(`Value not present for '${e}' in SSO Token${t?". Cannot refresh":""}. ${$}`,!1)},{writeFile:Re}=N.promises,ve=(e,s)=>{const t=b(e),o=JSON.stringify(s,null,2);return Re(t,o)},Z=new Date(0),Ie=(e={})=>async({callerClientConfig:s}={})=>{const t={...e,parentClientConfig:{...s,...e.parentClientConfig}};t.logger?.debug("@aws-sdk/token-providers - fromSso");const o=await X(t),n=j({profile:t.profile??s?.profile}),r=o[n];if(r){if(!r.sso_session)throw new p(`Profile '${n}' is missing required property 'sso_session'.`)}else throw new p(`Profile '${n}' could not be found in shared credentials file.`,!1);const f=r.sso_session,i=(await Q(t))[f];if(!i)throw new p(`Sso session '${f}' could not be found in shared credentials file.`,!1);for(const u of["sso_start_url","sso_region"])if(!i[u])throw new p(`Sso session '${f}' is missing required property '${u}'.`,!1);const g=i.sso_start_url,c=i.sso_region;let h;try{h=await U(f)}catch{throw new p(`The SSO session token associated with profile=${n} was not found or is invalid. ${$}`,!1)}w("accessToken",h.accessToken),w("expiresAt",h.expiresAt);const{accessToken:k,expiresAt:R}=h,S={token:k,expiration:new Date(R)};if(S.expiration.getTime()-Date.now()>ye)return S;if(Date.now()-Z.getTime()<30*1e3)return B(S),S;w("clientId",h.clientId,!0),w("clientSecret",h.clientSecret,!0),w("refreshToken",h.refreshToken,!0);try{Z.setTime(Date.now());const u=await ke(h,c,t);w("accessToken",u.accessToken),w("expiresIn",u.expiresIn);const y=new Date(Date.now()+u.expiresIn*1e3);try{await ve(f,{...h,accessToken:u.accessToken,expiresAt:y.toISOString(),refreshToken:u.refreshToken})}catch{}return{token:u.accessToken,expiration:y}}catch{return B(S),S}},x=!1,q=async({ssoStartUrl:e,ssoSession:s,ssoAccountId:t,ssoRegion:o,ssoRoleName:n,ssoClient:r,clientConfig:f,parentClientConfig:a,profile:i,logger:g})=>{let c;const h="To refresh this SSO session run aws sso login with the corresponding profile.";if(s)try{const C=await Ie({profile:i})();c={accessToken:C.token,expiresAt:new Date(C.expiration).toISOString()}}catch(C){throw new d(C.message,{tryNextLink:x,logger:g})}else try{c=await U(e)}catch{throw new d(`The SSO session associated with this profile is invalid. ${h}`,{tryNextLink:x,logger:g})}if(new Date(c.expiresAt).getTime()-Date.now()<=0)throw new d(`The SSO session associated with this profile has expired. ${h}`,{tryNextLink:x,logger:g});const{accessToken:k}=c,{SSOClient:R,GetRoleCredentialsCommand:S}=await l.e(845).then(l.bind(l,79845)),u=r||new R(Object.assign({},f??{},{logger:f?.logger??a?.logger,region:f?.region??o}));let y;try{y=await u.send(new S({accountId:t,roleName:n,accessToken:k}))}catch(C){throw new d(C,{tryNextLink:x,logger:g})}const{roleCredentials:{accessKeyId:m,secretAccessKey:v,sessionToken:ee,expiration:se,credentialScope:te,accountId:oe}={}}=y;if(!m||!v||!ee||!se)throw new d("SSO returns an invalid temporary credential.",{tryNextLink:x,logger:g});const H={accessKeyId:m,secretAccessKey:v,sessionToken:ee,expiration:new Date(se),...te&&{credentialScope:te},...oe&&{accountId:oe}};return s?z(H,"CREDENTIALS_SSO","s"):z(H,"CREDENTIALS_SSO_LEGACY","u"),H},Ae=(e,s)=>{const{sso_start_url:t,sso_account_id:o,sso_region:n,sso_role_name:r}=e;if(!t||!o||!n||!r)throw new d(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,{tryNextLink:!1,logger:s});return e},De=(e={})=>async({callerClientConfig:s}={})=>{e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");const{ssoStartUrl:t,ssoAccountId:o,ssoRegion:n,ssoRoleName:r,ssoSession:f}=e,{ssoClient:a}=e,i=j({profile:e.profile??s?.profile});if(!t&&!o&&!n&&!r&&!f){const c=(await X(e))[i];if(!c)throw new d(`Profile ${i} was not found.`,{logger:e.logger});if(!Te(c))throw new d(`Profile ${i} is not configured with SSO credentials.`,{logger:e.logger});if(c?.sso_session){const m=(await Q(e))[c.sso_session],v=` configurations in profile ${i} and sso-session ${c.sso_session}`;if(n&&n!==m.sso_region)throw new d("Conflicting SSO region"+v,{tryNextLink:!1,logger:e.logger});if(t&&t!==m.sso_start_url)throw new d("Conflicting SSO start_url"+v,{tryNextLink:!1,logger:e.logger});c.sso_region=m.sso_region,c.sso_start_url=m.sso_start_url}const{sso_start_url:h,sso_account_id:k,sso_region:R,sso_role_name:S,sso_session:u}=Ae(c,e.logger);return q({ssoStartUrl:h,ssoSession:u,ssoAccountId:k,ssoRegion:R,ssoRoleName:S,ssoClient:a,clientConfig:e.clientConfig,parentClientConfig:e.parentClientConfig,profile:i})}else{if(!t||!o||!n||!r)throw new d('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',{tryNextLink:!1,logger:e.logger});return q({ssoStartUrl:t,ssoSession:f,ssoAccountId:o,ssoRegion:n,ssoRoleName:r,ssoClient:a,clientConfig:e.clientConfig,parentClientConfig:e.parentClientConfig,profile:i})}}}};
