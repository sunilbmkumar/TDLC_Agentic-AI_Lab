"use strict";exports.id=632,exports.ids=[632],exports.modules={87251:(Ee,$,l)=>{l.d($,{fromHttp:()=>ge});var F=l(71500),ye=l(31932);class pe{constructor({name:e,kind:t=FieldPosition.HEADER,values:o=[]}){this.name=e,this.kind=t,this.values=o}add(e){this.values.push(e)}set(e){this.values=e}remove(e){this.values=this.values.filter(t=>t!==e)}toString(){return this.values.map(e=>e.includes(",")||e.includes(" ")?`"${e}"`:e).join(", ")}get(){return this.values}}class v{constructor(e){this.method=e.method||"GET",this.hostname=e.hostname||"localhost",this.port=e.port,this.query=e.query||{},this.headers=e.headers||{},this.body=e.body,this.protocol=e.protocol?e.protocol.slice(-1)!==":"?`${e.protocol}:`:e.protocol:"https:",this.path=e.path?e.path.charAt(0)!=="/"?`/${e.path}`:e.path:"/",this.username=e.username,this.password=e.password,this.fragment=e.fragment}static clone(e){const t=new v({...e,headers:{...e.headers}});return t.query&&(t.query=K(t.query)),t}static isInstance(e){if(!e)return!1;const t=e;return"method"in t&&"protocol"in t&&"hostname"in t&&"path"in t&&typeof t.query=="object"&&typeof t.headers=="object"}clone(){return v.clone(this)}}function K(n){return Object.keys(n).reduce((e,t)=>{const o=n[t];return{...e,[t]:Array.isArray(o)?[...o]:o}},{})}class W{constructor(e){this.statusCode=e.statusCode,this.reason=e.reason,this.headers=e.headers||{},this.body=e.body}static isInstance(e){if(!e)return!1;const t=e;return typeof t.statusCode=="number"&&typeof t.headers=="object"}}var B=l(26656),N=l(58611),_=l(65692);const M=["ECONNRESET","EPIPE","ETIMEDOUT"],j=n=>{const e={};for(const t of Object.keys(n)){const o=n[t];e[t]=Array.isArray(o)?o.join(","):o}return e},d={setTimeout:(n,e)=>setTimeout(n,e),clearTimeout:n=>clearTimeout(n)},L=1e3,z=(n,e,t=0)=>{if(!t)return-1;const o=s=>{const r=d.setTimeout(()=>{n.destroy(),e(Object.assign(new Error(`Socket timed out without establishing a connection within ${t} ms`),{name:"TimeoutError"}))},t-s),i=c=>{c?.connecting?c.on("connect",()=>{d.clearTimeout(r)}):d.clearTimeout(r)};n.socket?i(n.socket):n.on("socket",i)};return t<2e3?(o(0),0):d.setTimeout(o.bind(null,L),L)},V=3e3,Z=(n,{keepAlive:e,keepAliveMsecs:t},o=V)=>{if(e!==!0)return-1;const s=()=>{n.socket?n.socket.setKeepAlive(e,t||0):n.on("socket",r=>{r.setKeepAlive(e,t||0)})};return o===0?(s(),0):d.setTimeout(s,o)},k=3e3,G=(n,e,t=0)=>{const o=s=>{const r=t-s,i=()=>{n.destroy(),e(Object.assign(new Error(`Connection timed out after ${t} ms`),{name:"TimeoutError"}))};n.socket?n.socket.setTimeout(r,i):n.setTimeout(r,i)};return 0<t&&t<6e3?(o(0),0):d.setTimeout(o.bind(null,t===0?0:k),k)};var H=l(2203);const U=1e3;async function J(n,e,t=U){const o=e.headers??{},s=o.Expect||o.expect;let r=-1,i=!0;s==="100-continue"&&(i=await Promise.race([new Promise(c=>{r=Number(d.setTimeout(c,Math.max(U,t)))}),new Promise(c=>{n.on("continue",()=>{d.clearTimeout(r),c(!0)}),n.on("response",()=>{d.clearTimeout(r),c(!1)}),n.on("error",()=>{d.clearTimeout(r),c(!1)})})])),i&&Q(n,e.body)}function Q(n,e){if(e instanceof H.Readable){e.pipe(n);return}if(e){if(Buffer.isBuffer(e)||typeof e=="string"){n.end(e);return}const t=e;if(typeof t=="object"&&t.buffer&&typeof t.byteOffset=="number"&&typeof t.byteLength=="number"){n.end(Buffer.from(t.buffer,t.byteOffset,t.byteLength));return}n.end(Buffer.from(e));return}n.end()}const Ce=0;class R{static create(e){return typeof e?.handle=="function"?e:new R(e)}static checkSocketUsage(e,t,o=console){const{sockets:s,requests:r,maxSockets:i}=e;if(typeof i!="number"||i===1/0)return t;const c=15e3;if(Date.now()-c<t)return t;if(s&&r)for(const h in s){const T=s[h]?.length??0,m=r[h]?.length??0;if(T>=i&&m>=2*i)return o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${T} and ${m} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),Date.now()}return t}constructor(e){this.socketWarningTimestamp=0,this.metadata={handlerProtocol:"http/1.1"},this.configProvider=new Promise((t,o)=>{typeof e=="function"?e().then(s=>{t(this.resolveDefaultConfig(s))}).catch(o):t(this.resolveDefaultConfig(e))})}resolveDefaultConfig(e){const{requestTimeout:t,connectionTimeout:o,socketTimeout:s,httpAgent:r,httpsAgent:i}=e||{},c=!0,h=50;return{connectionTimeout:o,requestTimeout:t??s,httpAgent:(()=>r instanceof N.Agent||typeof r?.destroy=="function"?r:new N.Agent({keepAlive:c,maxSockets:h,...r}))(),httpsAgent:(()=>i instanceof _.Agent||typeof i?.destroy=="function"?i:new _.Agent({keepAlive:c,maxSockets:h,...i}))(),logger:console}}destroy(){this.config?.httpAgent?.destroy(),this.config?.httpsAgent?.destroy()}async handle(e,{abortSignal:t}={}){return this.config||(this.config=await this.configProvider),new Promise((o,s)=>{let r;const i=[],c=async a=>{await r,i.forEach(d.clearTimeout),o(a)},h=async a=>{await r,i.forEach(d.clearTimeout),s(a)};if(!this.config)throw new Error("Node HTTP request handler config is not resolved");if(t?.aborted){const a=new Error("Request aborted");a.name="AbortError",h(a);return}const T=e.protocol==="https:",m=T?this.config.httpsAgent:this.config.httpAgent;i.push(d.setTimeout(()=>{this.socketWarningTimestamp=R.checkSocketUsage(m,this.socketWarningTimestamp,this.config.logger)},this.config.socketAcquisitionWarningTimeout??(this.config.requestTimeout??2e3)+(this.config.connectionTimeout??1e3)));const w=(0,B.G)(e.query||{});let I;if(e.username!=null||e.password!=null){const a=e.username??"",f=e.password??"";I=`${a}:${f}`}let A=e.path;w&&(A+=`?${w}`),e.fragment&&(A+=`#${e.fragment}`);let p=e.hostname??"";p[0]==="["&&p.endsWith("]")?p=e.hostname.slice(1,-1):p=e.hostname;const b={headers:e.headers,host:p,method:e.method,path:A,port:e.port,agent:m,auth:I},y=(T?_.request:N.request)(b,a=>{const f=new W({statusCode:a.statusCode||-1,reason:a.statusMessage,headers:j(a.headers),body:a});c({response:f})});if(y.on("error",a=>{M.includes(a.code)?h(Object.assign(a,{name:"TimeoutError"})):h(a)}),t){const a=()=>{y.destroy();const f=new Error("Request aborted");f.name="AbortError",h(f)};if(typeof t.addEventListener=="function"){const f=t;f.addEventListener("abort",a,{once:!0}),y.once("close",()=>f.removeEventListener("abort",a))}else t.onabort=a}i.push(z(y,h,this.config.connectionTimeout)),i.push(G(y,h,this.config.requestTimeout));const S=b.agent;typeof S=="object"&&"keepAlive"in S&&i.push(Z(y,{keepAlive:S.keepAlive,keepAliveMsecs:S.keepAliveMsecs})),r=J(y,e,this.config.requestTimeout).catch(a=>(i.forEach(d.clearTimeout),s(a)))})}updateHttpClientConfig(e,t){this.config=void 0,this.configProvider=this.configProvider.then(o=>({...o,[e]:t}))}httpHandlerConfigs(){return this.config??{}}}var we=l(85675);class Ae{constructor(e){this.sessions=[],this.sessions=e??[]}poll(){if(this.sessions.length>0)return this.sessions.shift()}offerLast(e){this.sessions.push(e)}contains(e){return this.sessions.includes(e)}remove(e){this.sessions=this.sessions.filter(t=>t!==e)}[Symbol.iterator](){return this.sessions[Symbol.iterator]()}destroy(e){for(const t of this.sessions)t===e&&(t.destroyed||t.destroy())}}class Se{constructor(e){if(this.sessionCache=new Map,this.config=e,this.config.maxConcurrency&&this.config.maxConcurrency<=0)throw new RangeError("maxConcurrency must be greater than zero.")}lease(e,t){const o=this.getUrlString(e),s=this.sessionCache.get(o);if(s){const h=s.poll();if(h&&!this.config.disableConcurrency)return h}const r=http2.connect(o);this.config.maxConcurrency&&r.settings({maxConcurrentStreams:this.config.maxConcurrency},h=>{if(h)throw new Error("Fail to set maxConcurrentStreams to "+this.config.maxConcurrency+"when creating new session for "+e.destination.toString())}),r.unref();const i=()=>{r.destroy(),this.deleteSession(o,r)};r.on("goaway",i),r.on("error",i),r.on("frameError",i),r.on("close",()=>this.deleteSession(o,r)),t.requestTimeout&&r.setTimeout(t.requestTimeout,i);const c=this.sessionCache.get(o)||new NodeHttp2ConnectionPool;return c.offerLast(r),this.sessionCache.set(o,c),r}deleteSession(e,t){const o=this.sessionCache.get(e);!o||!o.contains(t)||(o.remove(t),this.sessionCache.set(e,o))}release(e,t){const o=this.getUrlString(e);this.sessionCache.get(o)?.offerLast(t)}destroy(){for(const[e,t]of this.sessionCache){for(const o of t)o.destroyed||o.destroy(),t.remove(o);this.sessionCache.delete(e)}}setMaxConcurrentStreams(e){if(e&&e<=0)throw new RangeError("maxConcurrentStreams must be greater than zero.");this.config.maxConcurrency=e}setDisableConcurrentStreams(e){this.config.disableConcurrency=e}getUrlString(e){return e.destination.toString()}}class x{static create(e){return typeof e?.handle=="function"?e:new x(e)}constructor(e){this.metadata={handlerProtocol:"h2"},this.connectionManager=new NodeHttp2ConnectionManager({}),this.configProvider=new Promise((t,o)=>{typeof e=="function"?e().then(s=>{t(s||{})}).catch(o):t(e||{})})}destroy(){this.connectionManager.destroy()}async handle(e,{abortSignal:t}={}){this.config||(this.config=await this.configProvider,this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams||!1),this.config.maxConcurrentStreams&&this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams));const{requestTimeout:o,disableConcurrentStreams:s}=this.config;return new Promise((r,i)=>{let c=!1,h;const T=async u=>{await h,r(u)},m=async u=>{await h,i(u)};if(t?.aborted){c=!0;const u=new Error("Request aborted");u.name="AbortError",m(u);return}const{hostname:w,method:I,port:A,protocol:p,query:b}=e;let O="";if(e.username!=null||e.password!=null){const u=e.username??"",E=e.password??"";O=`${u}:${E}@`}const y=`${p}//${O}${w}${A?`:${A}`:""}`,S={destination:new URL(y)},a=this.connectionManager.lease(S,{requestTimeout:this.config?.sessionTimeout,disableConcurrentStreams:s||!1}),f=u=>{s&&this.destroySession(a),c=!0,m(u)},D=buildQueryString(b||{});let P=e.path;D&&(P+=`?${D}`),e.fragment&&(P+=`#${e.fragment}`);const g=a.request({...e.headers,[constants.HTTP2_HEADER_PATH]:P,[constants.HTTP2_HEADER_METHOD]:I});if(a.ref(),g.on("response",u=>{const E=new HttpResponse({statusCode:u[":status"]||-1,headers:getTransformedHeaders(u),body:g});c=!0,T({response:E}),s&&(a.close(),this.connectionManager.deleteSession(y,a))}),o&&g.setTimeout(o,()=>{g.close();const u=new Error(`Stream timed out because of no activity for ${o} ms`);u.name="TimeoutError",f(u)}),t){const u=()=>{g.close();const E=new Error("Request aborted");E.name="AbortError",f(E)};if(typeof t.addEventListener=="function"){const E=t;E.addEventListener("abort",u,{once:!0}),g.once("close",()=>E.removeEventListener("abort",u))}else t.onabort=u}g.on("frameError",(u,E,Te)=>{f(new Error(`Frame type id ${u} in stream id ${Te} has failed with code ${E}.`))}),g.on("error",f),g.on("aborted",()=>{f(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${g.rstCode}.`))}),g.on("close",()=>{a.unref(),s&&a.destroy(),c||f(new Error("Unexpected error: http2 request did not get a response"))}),h=writeRequestBody(g,e,o)})}updateHttpClientConfig(e,t){this.config=void 0,this.configProvider=this.configProvider.then(o=>({...o,[e]:t}))}httpHandlerConfigs(){return this.config??{}}destroySession(e){e.destroyed||e.destroy()}}class ve extends H.Writable{constructor(){super(...arguments),this.bufferedBytes=[]}_write(e,t,o){this.bufferedBytes.push(e),o()}}const Re=n=>X(n)?Y(n):new Promise((e,t)=>{const o=new Collector;n.pipe(o),n.on("error",s=>{o.end(),t(s)}),o.on("error",t),o.on("finish",function(){const s=new Uint8Array(Buffer.concat(this.bufferedBytes));e(s)})}),X=n=>typeof ReadableStream=="function"&&n instanceof ReadableStream;async function Y(n){const e=[],t=n.getReader();let o=!1,s=0;for(;!o;){const{done:c,value:h}=await t.read();h&&(e.push(h),s+=h.length),o=c}const r=new Uint8Array(s);let i=0;for(const c of e)r.set(c,i),i+=c.length;return r}var C=l(3631),q=l(91943),ee=l.n(q);const Ie="127.0.0.0/8",be="::1/128",te="169.254.170.2",ne="169.254.170.23",oe="[fd00:ec2::23]",se=(n,e)=>{if(n.protocol!=="https:"&&!(n.hostname===te||n.hostname===ne||n.hostname===oe)){if(n.hostname.includes("[")){if(n.hostname==="[::1]"||n.hostname==="[0000:0000:0000:0000:0000:0000:0000:0001]")return}else{if(n.hostname==="localhost")return;const t=n.hostname.split("."),o=s=>{const r=parseInt(s,10);return 0<=r&&r<=255};if(t[0]==="127"&&o(t[1])&&o(t[2])&&o(t[3])&&t.length===4)return}throw new C.C1(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`,{logger:e})}};var re=l(23007),ie=l(26769);function ce(n){return new v({protocol:n.protocol,hostname:n.hostname,port:Number(n.port),path:n.pathname,query:Array.from(n.searchParams.entries()).reduce((e,[t,o])=>(e[t]=o,e),{}),fragment:n.hash})}async function ae(n,e){const o=await(0,ie.c9)(n.body).transformToString();if(n.statusCode===200){const s=JSON.parse(o);if(typeof s.AccessKeyId!="string"||typeof s.SecretAccessKey!="string"||typeof s.Token!="string"||typeof s.Expiration!="string")throw new C.C1("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }",{logger:e});return{accessKeyId:s.AccessKeyId,secretAccessKey:s.SecretAccessKey,sessionToken:s.Token,expiration:(0,re.parseRfc3339DateTime)(s.Expiration)}}if(n.statusCode>=400&&n.statusCode<500){let s={};try{s=JSON.parse(o)}catch{}throw Object.assign(new C.C1(`Server responded with status: ${n.statusCode}`,{logger:e}),{Code:s.Code,Message:s.Message})}throw new C.C1(`Server responded with status: ${n.statusCode}`,{logger:e})}const he=(n,e,t)=>async()=>{for(let o=0;o<e;++o)try{return await n()}catch{await new Promise(r=>setTimeout(r,t))}return await n()},ue="AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",fe="http://169.254.170.2",de="AWS_CONTAINER_CREDENTIALS_FULL_URI",le="AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",me="AWS_CONTAINER_AUTHORIZATION_TOKEN",ge=(n={})=>{n.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");let e;const t=n.awsContainerCredentialsRelativeUri??process.env[ue],o=n.awsContainerCredentialsFullUri??process.env[de],s=n.awsContainerAuthorizationToken??process.env[me],r=n.awsContainerAuthorizationTokenFile??process.env[le],i=n.logger?.constructor?.name==="NoOpLogger"||!n.logger?console.warn:n.logger.warn;if(t&&o&&(i("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."),i("awsContainerCredentialsFullUri will take precedence.")),s&&r&&(i("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."),i("awsContainerAuthorizationToken will take precedence.")),o)e=o;else if(t)e=`${fe}${t}`;else throw new C.C1(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`,{logger:n.logger});const c=new URL(e);se(c,n.logger);const h=new R({requestTimeout:n.timeout??1e3,connectionTimeout:n.timeout??1e3});return he(async()=>{const T=ce(c);s?T.headers.Authorization=s:r&&(T.headers.Authorization=(await ee().readFile(r)).toString());try{const m=await h.handle(T);return ae(m.response).then(w=>(0,F.g)(w,"CREDENTIALS_HTTP","z"))}catch(m){throw new C.C1(String(m),{logger:n.logger})}},n.maxRetries??3,n.timeout??1e3)}}};
